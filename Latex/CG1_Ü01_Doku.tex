\documentclass[14pt]{extarticle}

\usepackage[utf8]{inputenc}
\usepackage{ngerman}

\usepackage{array}
\usepackage{amsmath}

\title{Bericht Todesstern U1}
\author{Charline Waldrich, Robert Ullmann, Julian Dobrot}
\date{30. Oktober 2015}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Aufgabenstelung}

\subsection{ImageViewer}
Der ImageViewer ist ein Programm mit dem eine Bilddatei von der Festplatte ausgewählt werden kann und dieses in der GUI angezeigt wird. 
\subsection{ImageSaver}
Der ImageSaver ist ein Programm walches ein Bild erzeugt, dass so groß ist wie das Fenster.
Das Bild ist Schwarz und beinhaltet einen diagonalen roten Strich. Über eine Menüzeile kann das Bild in den Formaten PNG und JPG gespeichert werden.
\subsection{Matrizen- und Vectorenbibliothek}
Die Matritzen- und Vektorenbibliothek beinhaltet die folgenden fünf Klassen mit ihren Methoden um Operationen 
zur berechnung mit Matrix- und Vectorobjekten durchführen zu können:

\begin{itemize}
\item Eine Main, um die Testfälle aus der Aufgabenstellung durchzuführen.
\item Point3
\item Mat3x3
\item Vector3 
\item Normal3
\end{itemize}


\section{Lösungsstrategien}
\subsection{ImageViewer}
Der ImageViewer öffnet beim Starten einen Dialog um eine Bilddatei im PNG oder JPG- Format auszuwählen. Das ausgewählte Bild wird in einem Fenster, passend zur Größe, angezeigt.
\subsection{ImageSaver}
Der ImageSaver nutzt als Grundlage die JavaFX Applikation. Ich habe mich für die VBox als Grundlage des Fensters entscheiden da diese alle hinzugefügten Elemente automatisch untereinander anordnet. Um ein Bild Pixel für Pixel zu erzeugen, braucht es ein WritableImage Objekt welches der ImageView übergeben wird, um es darzustellen und abzuspeichern. 
\newline
Das erzeugte Bild muss in ein BufferedImage umgewandelt werden um die Speicherung zu ermöglichen. Als PNG Datei kann es ohne große Umwege umgewandelt werden, doch da eine JPG Datei einen Alpha-Kanal besitzt ist diese Art der Speicherung erst nach dem erstellen eines weiteren BufferedImage mit Byte Basiertem Index, welches danach in eine 2D Grafik umgewandelt werden muss, möglich.  

\subsection{Matrizen- und Vektorenbibliothek}
Die Klassen wurden nach den Klassendiagrammen angelegt und erfüllen die im Aufgabentext beschriebenen mathematischen Operationen. Die im vorherigen Semester erlernten mathematischen Fähigkeiten  wurden angewendet um die Problemstellungen zu realisieren und programmiertechnisch umzusetzen. Zur Lösung der reflectedOn Methode wurde die Mathematik recherchiert und umgesetzt.

\section{Implementierungen}
\subsection{ImageViewer}
Der ImageViewer besteht aus zwei Methoden. Die erste Methode ist die Java-FX \textbf{start}-Methode, welche das Layout beinhaltet. Dieses besteht aus einer BorderPane und darin enthalten eine ImageView, welche das Bild anzeigt. \\
Die zweite Methode ist die \textbf{openFileDialog}-Methode. Diese Methode dient der Auswahl des Bildes und gibt das ausgewählte File zurück an die start-Methode.
\subsection{ImageSaver}
Die ImageSaver Klasse besteht aus zwei öffentlichen Methoden, "start" und "main". 
Hinzu kommen vier private Methoden. Die initializeMenu Methode zum Einrichten der Menüleiste, welche in der Startmethode aufgerufen wird, zwei Methoden zum Erstellen des Bildes und eine weitere zum Abspeichern dessen. 
\newline
Die drawPicture Methode wird in der Start Methode aufgerufen sobald sich die Höhe oder Breite des Fensters ändert. Diese wiederum ruft in einer verschachtelten for-Schleife die getColor Methode auf, welche für jeden Bildpixel mit den übergebenen Koordinaten x und y, die Farbgebung bestimmt. 
\newline
In der saveFile Methode wird der Speicherdialog Initialisiert und die Möglichkeit das Pixelbild als JPG oder PNG Datei zu speichern wird gegeben. 
\newline
Eine Verknüpfung der beiden Klassen ImageSaver und ImageViewer wäre eine sinnvolle Implementierung, denn durch hinzufügen einiger Menüpunkte könnte man so dem User die Möglichkeit bieten sich zwischen dem erstellen eines pixelbasiertem, oder dem Anzeigen eines bereits existierendem Bildes zu entscheiden. 

\subsection{Matrizen- und Vektorenbibliothek}
\textbf{Point3:} Ein Punkt im dreidimensionalem Raum mit seinen x,y,z Werten. Die Klasse stellt Methoden bereit um einen Punkt mit anderen Objekten aus der Bibliothek zu subtrahieren und zu addieren.
\\\textbf{Mat3x3:} Im Konstruktor dieser Klasse sollen die neun Elemente einer 3x3 Matrix übergeben werden und die Determinante dieser Matrix wird bei der Initialisierung berechnet. Die Klasse enthält verschiedene Methoden um Operationen mit der übergebenen Matrix durchzuführen und diese zu verändern. 
\\\textbf{Normal3:} Eine Normale auf einer Oberfläche. Die x,y,z Werte der Normalen werden bei ihrer Initialisierung als unveränderliche Attribute übergeben. Des weiteren enthält die Klasse Methoden für Operationen zur Berechnung von Multiplikationen mit double Werten, die Addition mit anderen Normal3 Objekten und dem Kreuzprodukt mit Vektoren.
\\\textbf{Vector3:} Diese Klasse stellt einen dreidimensionalen Vektor dar und ermöglicht mit ihren Methoden verschiedene Operationen.


\section{Besondere Probleme oder Schwierigkeiten bei der Bearbeitung}
\subsection{ImageViewer}
Bei der Implementierung des ImageViewers kam es zu keinen besonderen Problemen oder Schwierigkeiten.
\subsection{ImageSaver}
Damit der ImageSaver, jedes Mal wenn der Nutzer die Größe des Fensters verstellt, ein neues Pixelbild mit passender Größe kreiert, hätte ich gern mit einem PropertyBinding gearbeitet. 
Leider bietet weder die ImageViewer noch die WritableImage Klasse ein solches an. Daher habe ich die Klasse so geschrieben, dass die DrawPicture Methode (dank eines Listeners) jedes Mal aufs Neue aufgerufen wird, wenn sich Höhe oder Breite des Fensters ändern. 
\newline
Damit nicht mehrere Bilder dem Fenster hinzugefügt werden, wird zu Anfang des Methodenaufrufs die ImageView stets von der Bilduntergrundfläche (VBox root) gelöscht und nach erstellen des neuen Bildes wieder hinzugefügt. 
\subsection{Matrizen- und Vektorenbibliothek}
Für die reflectedOn Methode wurde die Formel 
\begin{math} R=2(N*L)N-L \end{math}
angewendet.  Wobei R der reflektierte Vektor ist, N die Normale an der reflektiert wird und L ein normalisierter Vektor der in Richtung der Lichtquelle zeigt, dies ist das über den Parameter der Methode übergebene Normal3 Objekt. Die Schwierigkeit in der Umsetzung der Mathematik in den Programmcode bestand darin, dass die Formel umgestellt werden musste. So wird in der Methode erst die übergebene Normale mit -1 multipliziert, was den letzten Teil der Formel repräsentiert. 

\section{Zeitbedarf}
\begin{center}
\begin{tabular}{cr}
ImageViewer	  \	&80 min	\\
ImageSaver 	\	&240 min	\\
Bibliotheken \	&240 min	\\
Bericht  \		&180 min	 \\
	\hline
	&740 min
\end{tabular}
\end{center}

\section{Quellen}
https://asalga.wordpress.com/2012/09/23/understanding-vector-reflection-visually/


\end{document}